# backend/app/schemas/tool.py
from pydantic import BaseModel, Field
from typing import Dict, Any, List, Optional, Union, Literal
from datetime import datetime # Added for the new ToolRead schema

# --- Common Schema Definitions ---

class ToolParameter(BaseModel):
    """Defines a single parameter for a tool."""
    name: str = Field(..., description="The name of the parameter.")
    type: str = Field(..., description="The data type of the parameter (e.g., 'string', 'integer', 'boolean', 'array', 'object').")
    description: str = Field(..., description="A description of the parameter's purpose.")
    required: bool = Field(False, description="Whether the parameter is required for the tool call.")
    # For more complex types like arrays or objects, you might need 'items' or 'properties'
    items: Optional[Dict[str, Any]] = Field(None, description="Schema for items if the parameter is an array.")
    # If type is 'object', define properties (like a nested ToolParameter)
    # Using 'dict' instead of 'ToolParameter' directly to avoid circular dependency issues and match JSON structure
    properties: Optional[Dict[str, Any]] = Field(None, description="Properties if the parameter is an object (key-value pairs of schemas).")


class MCPToolDefinition(BaseModel):
    """
    Schema representing the definition of a tool,
    which can be consumed by an LLM or a tool registry.
    """
    name: str = Field(..., description="The unique name of the tool (e.g., 'search_web', 'send_email').")
    description: str = Field(..., description="A clear, concise description of what the tool does.")
    # This 'parameters' field is for describing the tool to the LLM, often a list of parameter definitions.
    parameters: List[ToolParameter] = Field(
        default_factory=list,
        description="A list of parameters the tool accepts, each with its name, type, and description."
    )


class MCPToolCall(BaseModel):
    """
    Schema representing a call to execute a specific tool with its arguments.
    This is typically generated by the LLM.
    """
    tool_name: str = Field(..., description="The name of the tool to be called.")
    tool_arguments: Dict[str, Any] = Field(
        default_factory=dict,
        description="A dictionary of arguments for the tool, where keys are parameter names."
    )
    call_id: str | None = Field(None, description="A unique identifier for this specific tool call.")


class MCPToolResponse(BaseModel):
    """
    Schema representing the response/output from a tool execution.
    """
    tool_name: str = Field(..., description="The name of the tool that was called.")
    status: Literal["success", "error"] = Field(..., description="The execution status of the tool call.")
    output: Union[str, Dict[str, Any]] = Field(..., description="The output of the tool execution. Can be a string or a dictionary.")
    call_id: str | None = Field(None, description="The unique identifier for the tool call, matching the request's call_id.")


# --- NEW: Schemas for Tool Management (for API CRUD operations on the 'Tool' database model) ---

# Base schema for common tool attributes that will be stored in the database
class ToolBase(BaseModel):
    name: str = Field(..., min_length=1, max_length=100, description="Unique name of the tool.")
    description: str = Field(..., min_length=10, description="A brief description of what the tool does.")
    # IMPORTANT: 'parameters' here is a Dict[str, Any] because it stores the JSON schema object directly
    # This will typically conform to a subset of JSON Schema specification for tool parameters,
    # e.g., {"type": "object", "properties": {"arg1": {"type": "string"}}, "required": ["arg1"]}
    parameters: Dict[str, Any] = Field({}, description="JSON schema defining the input parameters for the tool.")
    code: str = Field(..., min_length=10, description="The Python source code for the tool's execution logic.")

# Schema for creating a new tool (all ToolBase fields are required)
class ToolCreate(ToolBase):
    pass

# Schema for reading a tool (includes database-generated fields)
class ToolRead(ToolBase):
    id: int = Field(..., description="The unique database ID of the tool.")
    created_at: datetime = Field(..., description="Timestamp when the tool was created.")
    updated_at: Optional[datetime] = Field(None, description="Timestamp when the tool was last updated.")

    class Config:
        from_attributes = True # This replaces orm_mode = True for Pydantic v2+

# Schema for updating an existing tool (all fields are optional for partial updates)
class ToolUpdate(BaseModel):
    name: Optional[str] = Field(None, min_length=1, max_length=100, description="New unique name of the tool.")
    description: Optional[str] = Field(None, min_length=10, description="New description of what the tool does.")
    parameters: Optional[Dict[str, Any]] = Field(None, description="New JSON schema defining the input parameters for the tool.")
    code: Optional[str] = Field(None, min_length=10, description="New Python source code for the tool's execution logic.")